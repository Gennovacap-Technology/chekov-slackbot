// Generated by CoffeeScript 1.9.3
(function() {
  var JOBS, Job, createNewJob, cronJob, difference, handleNewJob, registerNewJob, registerNewJobFromBrain, storeJobToBrain, syncJobs, unregisterJob, updateJobTimezone,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  cronJob = require('cron').CronJob;

  JOBS = {};

  createNewJob = function(robot, pattern, role, message) {
    var id, job;
    while ((id == null) || JOBS[id]) {
      id = Math.floor(Math.random() * 1000000);
    }
    job = registerNewJob(robot, id, pattern, role, message);
    robot.brain.data.cronjob[id] = job.serialize();
    return id;
  };

  registerNewJobFromBrain = function(robot, id, pattern, role, message, timezone) {
    return registerNewJob(robot, id, pattern, role, message, timezone);
  };

  storeJobToBrain = function(robot, id, job) {
    var envelope;
    robot.brain.data.cronjob[id] = job.serialize();
    envelope = {
      user: job.user,
      room: job.user.room
    };
    return robot.send(envelope, "Job " + id + " stored in brain asynchronously");
  };

  registerNewJob = function(robot, id, pattern, role, message, timezone) {
    var job;
    job = new Job(id, pattern, role, message, timezone);
    job.start(robot);
    return JOBS[id] = job;
  };

  unregisterJob = function(robot, id) {
    if (JOBS[id]) {
      JOBS[id].stop();
      delete robot.brain.data.cronjob[id];
      delete JOBS[id];
      return true;
    }
    return false;
  };

  handleNewJob = function(robot, msg, role, pattern, message) {
    var error, id;
    try {
      id = createNewJob(robot, pattern, role, message);
      return msg.send("Job " + id + " created");
    } catch (_error) {
      error = _error;
      return msg.send("Error caught parsing crontab pattern: " + error + ". See http://crontab.org/ for the syntax");
    }
  };

  updateJobTimezone = function(robot, id, timezone) {
    if (JOBS[id]) {
      JOBS[id].stop();
      JOBS[id].timezone = timezone;
      robot.brain.data.cronjob[id] = JOBS[id].serialize();
      JOBS[id].start(robot);
      return true;
    }
    return false;
  };

  syncJobs = function(robot) {
    var id, job, nonCachedJobs, nonStoredJobs, results;
    nonCachedJobs = difference(robot.brain.data.cronjob, JOBS);
    for (id in nonCachedJobs) {
      if (!hasProp.call(nonCachedJobs, id)) continue;
      job = nonCachedJobs[id];
      registerNewJobFromBrain.apply(null, [robot, id].concat(slice.call(job)));
    }
    nonStoredJobs = difference(JOBS, robot.brain.data.cronjob);
    results = [];
    for (id in nonStoredJobs) {
      if (!hasProp.call(nonStoredJobs, id)) continue;
      job = nonStoredJobs[id];
      results.push(storeJobToBrain(robot, id, job));
    }
    return results;
  };

  difference = function(obj1, obj2) {
    var diff, id, job;
    diff = {};
    for (id in obj1) {
      job = obj1[id];
      if (!(id in obj2)) {
        diff[id] = job;
      }
    }
    return diff;
  };

  module.exports = function(robot) {
    var base;
    (base = robot.brain.data).cronjob || (base.cronjob = {});
    robot.brain.on('loaded', (function(_this) {
      return function() {
        return syncJobs(robot);
      };
    })(this));
    robot.respond(/(?:new|add) job (.*) "(.*?)" to (.*) *$/i, function(msg) {
      if (robot.auth.hasRole(msg.envelope.user, 'admin')) {
        return handleNewJob(robot, msg, msg.match[3], msg.match[1], msg.match[2]);
      } else {
        return msg.send("You're not allowed to create role jobs.");
      }
    });
    robot.respond(/(?:list|ls) jobs?/i, function(msg) {
      var id, job, text;
      if (robot.auth.hasRole(msg.envelope.user, 'admin')) {
        text = '';
        for (id in JOBS) {
          job = JOBS[id];
          text += id + ": " + job.pattern + " @" + msg.message.user.room + " \"" + job.message + "\" for " + job.role + "\n";
        }
        if (text.length > 0) {
          return msg.send(text);
        }
      } else {
        return msg.send("This user is not allowed to list jobs.");
      }
    });
    robot.respond(/(?:rm|remove|del|delete) job (\d+)/i, function(msg) {
      var id;
      if (robot.auth.hasRole(msg.envelope.user, 'admin')) {
        if ((id = msg.match[1]) && unregisterJob(robot, id)) {
          return msg.send("Job " + id + " deleted");
        } else {
          return msg.send("Job " + id + " does not exist");
        }
      }
    });
    return robot.respond(/(?:tz|timezone) job (\d+) (.*)/i, function(msg) {
      var id, timezone;
      if ((id = msg.match[1]) && (timezone = msg.match[2]) && updateJobTimezone(robot, id, timezone)) {
        return msg.send("Job " + id + " updated to use " + timezone);
      } else {
        return msg.send("Job " + id + " does not exist");
      }
    });
  };

  Job = (function() {
    function Job(id, pattern, role, message, timezone) {
      this.id = id;
      this.pattern = pattern;
      this.message = message;
      this.timezone = timezone;
      this.role = role;
    }

    Job.prototype.start = function(robot) {
      this.cronjob = new cronJob(this.pattern, (function(_this) {
        return function() {
          return _this.sendMessageToRole(robot);
        };
      })(this), null, false, this.timezone);
      return this.cronjob.start();
    };

    Job.prototype.stop = function() {
      return this.cronjob.stop();
    };

    Job.prototype.serialize = function() {
      return [this.pattern, this.role, this.message, this.timezone];
    };

    Job.prototype.sendMessageToRole = function(robot) {
      var envelope, i, len, recipients, results, user;
      recipients = robot.auth.usersWithRole(this.role);
      results = [];
      for (i = 0, len = recipients.length; i < len; i++) {
        user = recipients[i];
        envelope = {
          user: user,
          room: user
        };
        results.push(robot.send(envelope, this.message));
      }
      return results;
    };

    return Job;

  })();

}).call(this);
